<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Word Psychic</title>
<link rel="icon" href="data:," />

<style>
  :root{
    --bg0:#050914;
    --bg1:#071024;

    --ink: rgba(233,243,255,.94);
    --muted: rgba(233,243,255,.72);

    --violetA: rgba(180,120,255,.55);
    --violetB: rgba(150,80,255,.35);
    --violetC: rgba(210,170,255,.25);

    --glass: rgba(18,24,44,.56);
    --glass2: rgba(10,14,28,.55);

    --btn: rgba(32,38,66,.72);
    --btn2: rgba(60,50,120,.55);
    --btnEdge: rgba(220,200,255,.35);

    --shadow: rgba(0,0,0,.45);
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color: var(--ink);
    background:
      radial-gradient(1200px 700px at 50% 20%, rgba(140,70,255,.18), transparent 55%),
      radial-gradient(900px 600px at 50% 70%, rgba(80,40,180,.12), transparent 60%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 18px;
  }

  .frame{
    width:min(980px, 96vw);
    max-width: 980px;
    display:grid;
    grid-template-columns: 1fr;
    gap: 16px;
    align-items:center;
    justify-items:center;
  }

  .titleWrap{
    position: relative;
    height: 56px;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .title{
    font-family: "Cinzel Decorative", ui-serif, Georgia, serif;
    letter-spacing: .06em;
    font-size: clamp(26px, 4vw, 40px);
    text-shadow: 0 2px 18px rgba(190,140,255,.25);
    opacity: 0;
    transform: translateY(6px);
    transition: opacity 900ms ease, transform 900ms ease;
  }
  .title.on{
    opacity: 1;
    transform: translateY(0);
  }

  .panel{
    width:min(820px, 96vw);
    border-radius: 26px;
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    box-shadow: 0 18px 60px rgba(0,0,0,.35);
    border: 1px solid rgba(210,170,255,.16);
    padding: 18px 18px 14px;
    position: relative;
    overflow:hidden;
  }

  .panel::before{
    content:"";
    position:absolute;
    inset:-2px;
    background:
      radial-gradient(900px 450px at 50% 0%, rgba(200,150,255,.14), transparent 55%),
      radial-gradient(700px 500px at 20% 30%, rgba(120,80,255,.10), transparent 60%),
      radial-gradient(700px 500px at 80% 30%, rgba(120,80,255,.10), transparent 60%);
    pointer-events:none;
  }

  .orbRow{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap: 10px;
    padding-top: 6px;
    position:relative;
    z-index:1;
  }

  .orb{
    width: min(360px, 72vw);
    aspect-ratio: 1/1;
    border-radius: 50%;
    position: relative;
    filter: drop-shadow(0 18px 38px rgba(0,0,0,.45));
  }

  /* Outer glow behind orb */
  .orbGlow{
    position:absolute;
    inset:-18%;
    border-radius:50%;
    background: radial-gradient(circle at 50% 55%, rgba(190,120,255,.28), transparent 60%);
    opacity: .65;
    transform: scale(.98);
    transition: opacity 260ms ease, transform 260ms ease;
  }
  .speaking .orbGlow{
    opacity: .95;
    transform: scale(1.02);
  }

  /* Glass sphere */
  .orbGlass{
    position:absolute;
    inset:0;
    border-radius:50%;
    background:
      radial-gradient(circle at 50% 78%, rgba(235,220,255,.22), transparent 52%),
      radial-gradient(circle at 50% 18%, rgba(0,0,0,.62), rgba(0,0,0,.18) 40%, rgba(120,80,255,.10) 62%, rgba(210,170,255,.08) 78%, rgba(0,0,0,.20) 100%);
    overflow:hidden;
    border: 1px solid rgba(255,255,255,.10);
    box-shadow:
      inset 0 0 0 1px rgba(210,170,255,.10),
      inset 0 -20px 45px rgba(0,0,0,.35);
  }

  /* Hard rim highlight + sparkle specks */
  .orbRim{
    position:absolute;
    inset:0;
    border-radius:50%;
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
  }
  .orbRim::before{
    content:"";
    position:absolute;
    inset: 1.6%;
    border-radius:50%;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.14);
    opacity:.8;
  }
  .orbRim::after{
    content:"";
    position:absolute;
    inset:0;
    border-radius:50%;
    background:
      radial-gradient(2px 2px at 20% 24%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(1.5px 1.5px at 28% 18%, rgba(255,255,255,.42), transparent 60%),
      radial-gradient(1.8px 1.8px at 76% 28%, rgba(255,255,255,.36), transparent 60%),
      radial-gradient(1.2px 1.2px at 68% 20%, rgba(255,255,255,.30), transparent 60%);
    opacity:.9;
    mix-blend-mode: screen;
  }

  /* Internal storm layers */
  .storm{
    position:absolute;
    inset:-10%;
    border-radius:50%;
    background:
      conic-gradient(from 90deg, rgba(160,90,255,.00), rgba(170,110,255,.22), rgba(140,80,255,.00), rgba(160,90,255,.18), rgba(160,90,255,.00)),
      conic-gradient(from 250deg, rgba(110,70,255,.00), rgba(160,120,255,.14), rgba(110,70,255,.00), rgba(160,120,255,.10), rgba(110,70,255,.00)),
      radial-gradient(circle at 55% 60%, rgba(200,160,255,.12), transparent 58%);
    filter: blur(6px) saturate(1.2);
    opacity: .85;
    animation: drift 12s linear infinite;
    transform-origin: 50% 50%;
    mix-blend-mode: screen;
  }
  @keyframes drift{
    0%{ transform: rotate(0deg) scale(1.02); }
    100%{ transform: rotate(360deg) scale(1.02); }
  }

  /* Highlight streak */
  .shine{
    position:absolute;
    inset:0;
    border-radius:50%;
    background:
      radial-gradient(220px 320px at 30% 20%, rgba(255,255,255,.20), transparent 55%),
      radial-gradient(120px 180px at 35% 30%, rgba(255,255,255,.10), transparent 60%);
    mix-blend-mode: screen;
    opacity:.9;
    pointer-events:none;
  }

  /* Base / cradle */
  .base{
    width: min(380px, 78vw);
    height: 78px;
    position: relative;
    margin-top: -16px;
  }
  .base::before{
    content:"";
    position:absolute;
    left:50%;
    top: 10px;
    transform: translateX(-50%);
    width: 92%;
    height: 42px;
    border-radius: 999px;
    background: linear-gradient(180deg, rgba(210,170,255,.20), rgba(20,24,44,.55));
    border: 1px solid rgba(220,200,255,.18);
    box-shadow: inset 0 10px 24px rgba(0,0,0,.35), 0 12px 25px rgba(0,0,0,.25);
  }
  .base::after{
    content:"";
    position:absolute;
    left:50%;
    top: 0;
    transform: translateX(-50%);
    width: 70%;
    height: 18px;
    border-radius: 999px;
    background: radial-gradient(closest-side, rgba(190,120,255,.20), transparent 70%);
    opacity:.9;
  }

  .screen{
    margin-top: -10px;
    white-space: pre-wrap;
    padding: 20px 20px 48px; /* bottom padding gives room above buttons */
    height: min(340px, 38vh);
    min-height: 190px;
    overflow: auto;
    border-radius: 18px;
    background: linear-gradient(180deg, var(--glass), var(--glass2));
    border: 1px solid rgba(220,200,255,.14);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    position: relative;
    z-index: 2;
    color: var(--ink);
    text-shadow: 0 1px 0 rgba(0,0,0,.35);
  }

  .controls{
    margin-top: -34px; /* pulls buttons up so they “sit” right under screen */
    display:flex;
    gap: 10px;
    justify-content:center;
    position: relative;
    z-index: 3;
    flex-wrap: wrap;
  }

  button{
    appearance:none;
    border: 1px solid rgba(220,200,255,.22);
    background: linear-gradient(180deg, rgba(50,46,90,.76), rgba(30,28,58,.72));
    color: var(--ink);
    padding: 12px 16px;
    border-radius: 14px;
    cursor:pointer;
    font-weight: 650;
    letter-spacing: .02em;
    box-shadow: 0 10px 24px rgba(0,0,0,.26), inset 0 0 0 1px rgba(255,255,255,.06);
    transition: transform 120ms ease, opacity 160ms ease, filter 160ms ease;
    min-width: 130px;
  }
  button:hover{ transform: translateY(-1px); }
  button:active{ transform: translateY(0px) scale(.99); }
  button[disabled]{
    opacity: .42;
    cursor: not-allowed;
    filter: grayscale(.2);
  }

  .footer{
    margin-top: 10px;
    width: min(820px, 96vw);
    display:flex;
    justify-content: space-between;
    gap: 12px;
    color: var(--muted);
    font-size: 12.5px;
    opacity: .92;
  }
  .footer a{ color: var(--muted); text-decoration: none; border-bottom: 1px dotted rgba(233,243,255,.28); }
  .footer a:hover{ opacity: 1; }

  .tiny{
    font-size: 12px;
    opacity: .75;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
</head>

<body>
  <div class="frame">
    <div class="titleWrap">
      <div id="title" class="title">The Word Psychic</div>
    </div>

    <div class="panel" id="panel">
      <div class="orbRow">
        <div class="orb" aria-hidden="true">
          <div class="orbGlow"></div>
          <div class="orbGlass">
            <div class="storm"></div>
            <div class="shine"></div>
            <div class="orbRim"></div>
          </div>
        </div>
        <div class="base" aria-hidden="true"></div>
      </div>

      <div id="screen" class="screen"></div>

      <div class="controls">
        <button id="btnStart">Start</button>
        <button id="btnYes" disabled>Yes</button>
        <button id="btnNo" disabled>No</button>
        <button id="btnEnd" disabled>End Session</button>
      </div>
    </div>

    <div class="footer">
      <div>© <span id="year"></span> Word Psychic</div>
      <div><a href="mailto:wordpsychic@gmail.com">wordpsychic@gmail.com</a></div>
    </div>
  </div>

<script>
(() => {
  // ====== CONFIG ======
  // If your backend is on the same domain (Render), keep "".
  // If you're testing locally with a separate backend, set e.g. "http://127.0.0.1:8001"
  const API_BASE = "";

  // Endpoints (match your FastAPI routes)
  // If your backend uses different paths, change ONLY these.
  const EP = {
    start: "/start",
    yes: "/yes",
    no: "/no",
    end: "/end"
  };

  // ====== UI ELEMENTS ======
  const titleEl = document.getElementById("title");
  const panelEl = document.getElementById("panel");
  const screenEl = document.getElementById("screen");

  const btnStart = document.getElementById("btnStart");
  const btnYes = document.getElementById("btnYes");
  const btnNo = document.getElementById("btnNo");
  const btnEnd = document.getElementById("btnEnd");

  document.getElementById("year").textContent = new Date().getFullYear();

  // ====== AUDIO (whoosh) ======
  // Safe: if audio fails to load, app still works.
  const whoosh = new Audio();
  whoosh.preload = "auto";
  // If you already have a whoosh file, set it here:
  // whoosh.src = "whoosh.mp3";
  // Otherwise we’ll use a tiny synthesized whoosh fallback.
  let whooshReady = false;
  whoosh.addEventListener("canplaythrough", () => { whooshReady = true; });

  function playWhooshSafe(){
    try{
      if (whoosh.src && whooshReady) {
        whoosh.currentTime = 0;
        whoosh.play().catch(()=>{});
      } else {
        // fallback: quick noise burst using WebAudio
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate/12));
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuffer;
        const filter = ctx.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.value = 800;
        const gain = ctx.createGain();
        gain.gain.value = 0.35;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
        noise.stop(ctx.currentTime + 0.22);
        setTimeout(()=>ctx.close().catch(()=>{}), 600);
      }
    } catch(e){}
  }

  // ====== STATE ======
  let started = false;
  let busy = false;
  let aborter = null;

  function setBusy(on){
    busy = on;
    // During requests: disable Yes/No; keep End enabled so user can always escape.
    btnYes.disabled = on || !started;
    btnNo.disabled  = on || !started;
    btnStart.disabled = on; // prevent double-start gibberish
    btnEnd.disabled = !started ? true : false; // enabled once started
  }

  function setStarted(on){
    started = on;
    btnStart.disabled = on ? true : false;
    btnYes.disabled = !on;
    btnNo.disabled = !on;
    btnEnd.disabled = !on;
  }

  function hardStopAll(){
    // Abort any fetch
    try{ if (aborter) aborter.abort(); } catch(e){}
    aborter = null;

    // Stop speech
    try{
      window.speechSynthesis.cancel();
    } catch(e){}

    // Remove speaking glow
    panelEl.classList.remove("speaking");

    busy = false;
    setStarted(false);
    setBusy(false);
  }

  // ====== SPEECH (safe + never blocks UI) ======
  function speakSafe(text){
    try{
      if (!text) return;
      if (!("speechSynthesis" in window)) return;

      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);

      // modest, clear pacing; tweak if you want
      u.rate = 0.92;
      u.pitch = 0.95;

      u.onstart = () => panelEl.classList.add("speaking");
      u.onend = () => panelEl.classList.remove("speaking");
      u.onerror = () => panelEl.classList.remove("speaking");

      window.speechSynthesis.speak(u);
    } catch(e){
      panelEl.classList.remove("speaking");
    }
  }

  // ====== RENDER ======
  function renderPayload(payload){
    // Accepts either:
    //  - { text: "...", speak: "..." }
    //  - { message: "...", speak: "..." }
    //  - plain string
    let text = "";
    let speak = "";

    if (payload == null) {
      text = "";
    } else if (typeof payload === "string") {
      text = payload;
      speak = payload;
    } else if (typeof payload === "object") {
      text = payload.text ?? payload.message ?? "";
      speak = payload.speak ?? text;
    }

    if (text) screenEl.textContent = text;
    if (speak) speakSafe(speak);

    // keep view pinned to top like your earlier “nice no-scroll” behavior
    screenEl.scrollTop = 0;
  }

  // ====== FETCH (safe + abortable) ======
  async function apiPost(path){
    aborter = new AbortController();
    const url = API_BASE + path;

    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({}),
      signal: aborter.signal
    });

    // if backend returns non-JSON, still show something readable
    const ct = res.headers.get("content-type") || "";
    let data;
    if (ct.includes("application/json")) {
      data = await res.json();
    } else {
      data = await res.text();
    }

    if (!res.ok) {
      const msg = (typeof data === "string") ? data : (data?.detail || data?.message || JSON.stringify(data));
      throw new Error(msg || ("HTTP " + res.status));
    }

    return data;
  }

  // ====== INTRO ======
  function runIntro(){
    // fade in title + whoosh, then always unlock Start
    titleEl.classList.add("on");
    playWhooshSafe();

    // The “freeze” you saw usually happens when UI never unlocks after intro.
    // Here: we ALWAYS render and unlock.
    setTimeout(() => {
      screenEl.textContent = "Tap 'Start' to summon the Word Psychic...\n\nYes opens the door, no keeps it shut.";
      btnStart.disabled = false;
      btnYes.disabled = true;
      btnNo.disabled = true;
      btnEnd.disabled = true;
      screenEl.scrollTop = 0;
    }, 520);
  }

  // ====== BUTTON HANDLERS ======
  btnStart.addEventListener("click", async () => {
    if (busy) return;
    setBusy(true);

    // If user clicks Start again later, do not re-run intro or stack speech.
    try{
      const data = await apiPost(EP.start);
      setStarted(true);
      renderPayload(data);
    } catch(err){
      // If API fails, still do not freeze: show error and allow retry.
      screenEl.textContent =
        "I tried to summon the Word Psychic, but the veil resisted.\n\n" +
        "Trouble details:\n" + String(err?.message || err) +
        "\n\nTry Start again. (If you’re testing locally, make sure the backend is running.)";
      setStarted(false);
    } finally {
      setBusy(false);
    }
  });

  btnYes.addEventListener("click", async () => {
    if (!started || busy) return;
    setBusy(true);
    try{
      const data = await apiPost(EP.yes);
      renderPayload(data);
    } catch(err){
      screenEl.textContent = "Something went wrong with 'Yes'.\n\n" + String(err?.message || err);
    } finally {
      setBusy(false);
    }
  });

  btnNo.addEventListener("click", async () => {
    if (!started || busy) return;
    setBusy(true);
    try{
      const data = await apiPost(EP.no);
      renderPayload(data);
    } catch(err){
      screenEl.textContent = "Something went wrong with 'No'.\n\n" + String(err?.message || err);
    } finally {
      setBusy(false);
    }
  });

  btnEnd.addEventListener("click", async () => {
    // End must ALWAYS work even if busy/frozen:
    // 1) hard stop local UI immediately
    // 2) best-effort notify backend
    hardStopAll();

    // Best effort backend call (won’t block UI)
    try{
      await apiPost(EP.end);
    } catch(e){ /* ignore */ }

    // Return to idle screen
    screenEl.textContent = "The candles dim...\n\nTap 'Start' to summon the Word Psychic again.";
    screenEl.scrollTop = 0;
    btnStart.disabled = false;
  });

  // Safety: if user navigates away or reloads mid-speech/fetch
  window.addEventListener("beforeunload", () => {
    try{ if (aborter) aborter.abort(); } catch(e){}
    try{ window.speechSynthesis.cancel(); } catch(e){}
  });

  // ====== BOOT ======
  btnStart.disabled = true;
  runIntro();
})();
</script>
</body>
</html>
